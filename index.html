<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSC Cropper (Fixed Nav & Count)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    
    <!-- Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <style>
        :root { --primary: #2563eb; --bg: #f3f4f6; --text: #1f2937; }
        * { box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; margin: 0; height: 100vh; background: var(--bg); color: var(--text); display: flex; flex-direction: column; overflow: hidden; }

        /* Header */
        header { background: #1e293b; color: white; padding: 0.5rem 1rem; display: flex; justify-content: space-between; align-items: center; height: 50px; flex-shrink: 0; }
        header h2 { margin: 0; font-size: 1rem; font-weight: 600; }
        .kbd { background: #334155; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 0.8rem; }
        .badge { background: #10b981; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; margin-left: 10px; color: white; font-weight: bold; }

        /* Layout */
        .workspace { display: grid; grid-template-columns: 1fr 350px; height: calc(100vh - 50px); }

        /* PDF Viewer */
        .pdf-container { position: relative; background: #525252; overflow: auto; display: flex; justify-content: center; padding: 2rem; }
        .canvas-wrapper { position: relative; box-shadow: 0 10px 25px rgba(0,0,0,0.5); background: white; cursor: crosshair; margin-bottom: 60px; }
        canvas { display: block; }

        /* --- TEXT LAYER (Fixed for Selection) --- */
        .textLayer { position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; opacity: 0.1; pointer-events: none; }
        .textLayer span { line-height: 1.0 !important; transform-origin: 0% 0%; }
        
        /* When Text Mode is Active */
        .canvas-wrapper.text-mode .textLayer { 
            pointer-events: auto; 
            z-index: 999; /* Sit on top of everything */
            opacity: 1; 
            background: rgba(59, 130, 246, 0.05); 
            cursor: text;
        }
        
        /* Selection Box */
        #selectionBox { position: absolute; border: 2px solid #ef4444; background: rgba(239, 68, 68, 0.1); display: none; pointer-events: none; z-index: 50; }

        /* Floating Controls */
        .pdf-controls {
            position: fixed; bottom: 20px; left: calc(50% - 175px);
            background: rgba(0,0,0,0.85); padding: 8px 16px; border-radius: 30px;
            display: flex; gap: 12px; align-items: center; z-index: 200; color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); backdrop-filter: blur(4px);
        }
        .pdf-controls button { background: transparent; border: none; color: white; cursor: pointer; font-size: 1.2rem; padding: 4px 8px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .pdf-controls button:hover { background: rgba(255,255,255,0.2); }

        /* Sidebar */
        .sidebar { background: #fff; border-left: 1px solid #e5e7eb; display: flex; flex-direction: column; overflow-y: auto; }
        .panel-section { padding: 1rem; border-bottom: 1px solid #e5e7eb; }
        input, select { width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #d1d5db; border-radius: 6px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        .task-area { background: #eff6ff; border: 2px solid #bfdbfe; border-radius: 8px; padding: 1rem; margin-top: 0.5rem; transition: background 0.2s; position: relative; }
        .task-area.flash { animation: flashGreen 0.5s ease-out; }
        @keyframes flashGreen { 0% { background-color: #86efac; } 100% { background-color: #eff6ff; } }

        #cropPreview { width: 100%; height: 150px; object-fit: contain; background: #fff; border: 1px solid #ddd; margin-bottom: 10px; }
        
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        .upload-btn { flex: 2; background: var(--primary); color: white; padding: 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; }
        .upload-btn:hover { background: #1d4ed8; }
        .upload-btn:disabled { background: #9ca3af; }
        .clear-btn { flex: 1; background: #fee2e2; color: #b91c1c; border: 1px solid #fecaca; border-radius: 6px; font-weight: 600; cursor: pointer; }

        .hidden { display: none; }
        .mode-indicator { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: #2563eb; color: white; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; font-weight: bold; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 300; }
        .canvas-wrapper.text-mode + .mode-indicator { opacity: 1; }
        .canvas-wrapper.ocr-mode + .mode-indicator { opacity: 1; background: #10b981; }
        .canvas-wrapper.ocr-mode { cursor: crosshair; }
        .ocr-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 8px; z-index: 400; display: none; }
        .ocr-loading.active { display: block; }
        .auto-filled { border-color: #10b981 !important; background-color: #ecfdf5; transition: 0.3s; }

        /* History List */
        .history-list { list-style: none; padding: 0; margin: 0; }
        .history-item { display: flex; justify-content: space-between; font-size: 0.8rem; padding: 6px 0; border-bottom: 1px solid #f0f0f0; color: #4b5563; }
        
        /* Modal */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 400px; border-radius: 8px; }
        #myUploadsModal .modal-content { width: 90%; max-width: 1200px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: #000; }
        
        /* Image Grid */
        .upload-item { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; transition: transform 0.2s, box-shadow 0.2s; }
        .upload-item:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .upload-item-image { width: 100%; height: 150px; object-fit: contain; background: #f9fafb; border-radius: 4px; margin-bottom: 8px; cursor: pointer; }
        .upload-item-id { font-weight: 600; color: #2563eb; font-size: 0.9rem; margin-bottom: 4px; cursor: pointer; user-select: none; padding: 4px 8px; border-radius: 4px; display: inline-block; transition: background 0.2s; }
        .upload-item-id:hover { background: #eff6ff; }
        .upload-item-id:active { background: #dbeafe; }
        .upload-item-time { font-size: 0.75rem; color: #6b7280; }
    </style>
</head>
<body>

    <header>
        <h2>‚ö° SSC Cropper <span class="badge">V4.1</span></h2>
        <div style="display:flex; gap:15px; align-items:center;">
            <button onclick="showMyUploads()" style="background:#2563eb; border:none; color:white; padding:5px 10px; border-radius:4px; cursor:pointer; font-size:0.8rem;">üñºÔ∏è My Uploads</button>
            <button onclick="showReport()" style="background:#4b5563; border:none; color:white; padding:5px 10px; border-radius:4px; cursor:pointer; font-size:0.8rem;">üìä Report</button>
            <button id="ocrModeBtn" onclick="toggleOCRMode()" style="background:#10b981; border:none; color:white; padding:5px 10px; border-radius:4px; cursor:pointer; font-size:0.8rem;">üîç OCR Mode</button>
            <span style="font-size: 0.85rem; opacity: 0.9;">Hold <span class="kbd">Ctrl</span> for Text ‚Ä¢ <span class="kbd">W</span> or <span class="kbd">Ctrl+W</span> for OCR ‚Ä¢ <span class="kbd">Esc</span> to Clear</span>
        </div>
    </header>

    <div class="workspace">
        <div class="pdf-container">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="pdfCanvas"></canvas>
                <div id="textLayer" class="textLayer"></div>
                <div id="selectionBox"></div>
            </div>
            
            <div class="mode-indicator" id="modeIndicator">TEXT MODE: Highlight or Click ID</div>
            <div class="ocr-loading" id="ocrLoading">
                <div style="text-align:center;">
                    <div style="font-size:1.2rem; margin-bottom:10px;">üîç Reading Text...</div>
                    <div style="font-size:0.9rem; opacity:0.8;" id="ocrProgress">Initializing OCR...</div>
                </div>
            </div>

            <div class="pdf-controls">
                <label for="pdfInput" style="cursor: pointer;" title="Open PDF">üìÇ</label>
                <input type="file" id="pdfInput" accept=".pdf" class="hidden">
                <div style="width: 1px; height: 16px; background: rgba(255,255,255,0.3); margin: 0 4px;"></div>
                <button onclick="changePage(-1)" title="Prev">‚Üê</button>
                <span id="pageIndicator" style="font-size: 0.9rem; min-width: 60px; text-align: center;">-- / --</span>
                <button onclick="changePage(1)" title="Next">‚Üí</button>
                <div style="width: 1px; height: 16px; background: rgba(255,255,255,0.3); margin: 0 4px;"></div>
                <button onclick="zoom(-0.2)">‚ûñ</button>
                <button onclick="zoom(0.2)">‚ûï</button>
            </div>
        </div>

        <div class="sidebar">
            <div class="panel-section">
                <div class="panel-title"><span>1. Tracking</span></div>
                <input type="text" id="workerName" placeholder="Enter Your Name (Required)" style="border: 2px solid #2563eb; background: #eff6ff;" onchange="saveConfig()">
                <input type="password" id="ghToken" placeholder="GitHub Token" onchange="saveConfig()">
                
                <div class="grid-2">
                    <select id="exam" onchange="saveConfig()"><option value="cgl">CGL</option><option value="chsl">CHSL</option><option value="mts">MTS</option><option value="cpo">CPO</option><option value="selection">Selection Post</option></select>
                    <select id="year" onchange="saveConfig()"></select>
                </div>
                <div class="grid-2">
                    <select id="tier" onchange="saveConfig()"><option value="tier1">Tier 1</option><option value="tier2">Tier 2</option></select>
                    <select id="lang" onchange="saveConfig()"><option value="en">English</option><option value="hi">Hindi</option></select>
                </div>
                <div class="grid-2">
                    <input type="date" id="examDate" onchange="saveConfig()">
                    <select id="shift" onchange="saveConfig()"><option value="shift1">Shift 1</option><option value="shift2">Shift 2</option><option value="shift3">Shift 3</option><option value="shift4">Shift 4</option></select>
                </div>
            </div>

            <div class="panel-section" style="background: #fff; flex: 1;">
                <div class="panel-title"><span>2. Crop & Upload</span></div>
                <div class="task-area" id="taskArea">
                    <img id="cropPreview" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
                    
                    <label style="font-size: 0.8rem; font-weight: bold; margin-bottom: 5px; display:block;">Question ID</label>
                    <input type="text" id="qId" placeholder="Click/Highlight ID..." style="font-weight: bold; font-size: 1.1rem; color: #2563eb; border: 2px solid #2563eb;">
                    
                    <div class="btn-group">
                        <button class="clear-btn" onclick="clearAll()" title="Press Esc to clear">‚ùå Clear</button>
                        <button id="uploadBtn" class="upload-btn" onclick="uploadImage()">‚¨ÜÔ∏è Upload</button>
                    </div>
                </div>
                <div style="margin-top:10px; font-size:0.8rem; color:#666; text-align: center;">Press <span class="kbd">Enter</span> to Upload</div>
            </div>

            <div class="panel-section">
                <div class="panel-title">
                    <span>Recent History (Unique: <strong id="uniqueCount">0</strong>)</span>
                    <button onclick="clearHistory()" style="background:none; border:none; color:#ef4444; font-size:0.7rem; cursor:pointer;">Clear</button>
                </div>
                <ul id="historyList" class="history-list"></ul>
            </div>
        </div>
    </div>

    <div id="reportModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="document.getElementById('reportModal').style.display='none'">&times;</span>
            <h3>üìä Total Upload Report (All Time)</h3>
            <div id="reportStatus">Loading data from GitHub...</div>
            <table id="reportTable" style="display:none; width:100%; margin-top:10px; border-collapse:collapse;">
                <thead><tr style="background:#f0f0f0;"><th style="padding:8px; border:1px solid #ddd;">Worker</th><th style="padding:8px; border:1px solid #ddd;">Count</th></tr></thead>
                <tbody id="reportBody"></tbody>
            </table>
        </div>
    </div>

    <div id="myUploadsModal" class="modal" onclick="if(event.target === this) document.getElementById('myUploadsModal').style.display='none'">
        <div class="modal-content" style="max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <span class="close" onclick="document.getElementById('myUploadsModal').style.display='none'">&times;</span>
            <h3>üñºÔ∏è My Recent Uploads (Last 30)</h3>
            <div id="myUploadsStatus" style="text-align:center; padding:20px; color:#666;">Loading...</div>
            <div id="myUploadsGrid" style="display:none; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:15px; margin-top:20px;"></div>
        </div>
    </div>

<script>
    const CONFIG = { repoOwner: 'nik-ma', repoName: 'images' };
    let pdfDoc = null, pageNum = 1, scale = 1.5, canvas = document.getElementById('pdfCanvas'), ctx = canvas.getContext('2d'), viewport = null;
    let isSelecting = false, startX, startY, rect = {}, blobToSend = null;
    
    // TRACKING SET FOR TODAY
    let uploadedIDs = new Set(); 

    window.onload = function() {
        populateYears(); loadConfig(); renderHistory();
        document.getElementById('pdfInput').addEventListener('change', loadPDF);
        
        const wrapper = document.getElementById('canvasWrapper');
        wrapper.addEventListener('mousedown', startSelection);
        wrapper.addEventListener('mousemove', updateSelection);
        window.addEventListener('mouseup', endSelection);
        document.addEventListener('mouseup', handleTextSelection); 

        // --- KEYBOARD LISTENERS ---
        document.addEventListener('keydown', function(e) {
            // 1. Enter = Upload
            if (e.key === 'Enter' && !document.getElementById('uploadBtn').disabled) {
                if(document.getElementById('qId').value && blobToSend) uploadImage();
            }
            // 2. Esc = Clear
            if (e.key === 'Escape') clearAll();
            
            // 3. Arrow Navigation (Simple: Left/Right)
            // Check if user is NOT typing in the Input box
            if (document.activeElement.tagName !== 'INPUT') {
                if (e.key === 'ArrowRight') changePage(1);
                if (e.key === 'ArrowLeft') changePage(-1);
            }
            
            // 4. Ctrl = Text Mode
            if (e.key === 'Control' || e.key === 'Meta') {
                const wrapper = document.getElementById('canvasWrapper');
                wrapper.classList.add('text-mode');
                wrapper.classList.remove('ocr-mode'); // Disable OCR when text mode is on
                updateModeIndicator('text');
                // Ensure text layer is interactive
                const textLayer = document.getElementById('textLayer');
                if (textLayer) {
                    textLayer.style.pointerEvents = 'auto';
                }
            }
            
            // 5. Ctrl+W or W = OCR Mode (toggle)
            if ((e.ctrlKey || e.metaKey) && (e.key === 'w' || e.key === 'W')) {
                // Ctrl+W always works, regardless of focus
                e.preventDefault();
                e.stopPropagation();
                toggleOCRMode();
            } else if (e.key === 'w' || e.key === 'W') {
                // W key - works even when input is focused
                const activeEl = document.activeElement;
                if (activeEl.tagName === 'INPUT' && activeEl.id === 'qId') {
                    // If in ID input, prevent typing and toggle OCR
                    e.preventDefault();
                    e.stopPropagation();
                    toggleOCRMode();
                    // Blur the input so it doesn't interfere
                    activeEl.blur();
                } else if (activeEl.tagName !== 'INPUT') {
                    // If not in any input, just toggle
                    toggleOCRMode();
                }
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.key === 'Control' || e.key === 'Meta') {
                const wrapper = document.getElementById('canvasWrapper');
                wrapper.classList.remove('text-mode');
                updateModeIndicator('none');
                // Disable text layer interaction
                const textLayer = document.getElementById('textLayer');
                if (textLayer) {
                    textLayer.style.pointerEvents = 'none';
                }
            }
        });
    };

    // --- MANAGER REPORT ---
    async function showReport() {
        const token = document.getElementById('ghToken').value;
        if(!token) { alert("Need GitHub token"); return; }
        document.getElementById('reportModal').style.display = 'block';
        document.getElementById('reportStatus').innerText = "Scanning commits...";
        document.getElementById('reportTable').style.display = 'none';

        try {
            // Fetch all commits (no date filter) - paginate through all pages
            let allCommits = [];
            let page = 1;
            let hasMore = true;
            
            while (hasMore) {
                const url = `https://api.github.com/repos/${CONFIG.repoOwner}/${CONFIG.repoName}/commits?per_page=100&page=${page}`;
                const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
                const commits = await res.json();
                
                if (commits.length === 0 || commits.length < 100) {
                    hasMore = false;
                }
                
                allCommits = allCommits.concat(commits);
                page++;
                
                // Safety limit to prevent infinite loops
                if (page > 50) break;
            }
            
            // Track unique IDs per user
            const userUniqueIDs = {}; // { user: Set of IDs }
            
            allCommits.forEach(c => {
                const msg = c.commit.message;
                // Extract user from commit message: "Upload filename.png (User: username)"
                const userMatch = msg.match(/User:\s*([^\)]+)/);
                const user = userMatch ? userMatch[1].trim() : 'Unknown';
                
                // Extract ID from filename in commit message: "Upload 123.png" or "Upload qid_A.png" or from path
                let id = null;
                const filenameMatch = msg.match(/Upload\s+([^\.\s]+)\.png/);
                if (filenameMatch) {
                    id = filenameMatch[1];
                } else {
                    // Try to extract from file path in commit
                    const pathMatch = msg.match(/ssc\/[^\/]+\/[^\/]+\/[^\/]+\/[^\/]+\/[^\/]+\/[^\/]+\/([^\.]+)\.png/);
                    if (pathMatch) {
                        id = pathMatch[1];
                    }
                }
                
                // Only count if we found an ID
                if (id) {
                    if (!userUniqueIDs[user]) {
                        userUniqueIDs[user] = new Set();
                    }
                    userUniqueIDs[user].add(id);
                }
            });
            
            // Convert Sets to counts and sort by count (descending)
            const counts = {};
            for (const [user, idSet] of Object.entries(userUniqueIDs)) {
                counts[user] = idSet.size;
            }
            
            const sortedUsers = Object.entries(counts).sort((a, b) => b[1] - a[1]);
            
            const tbody = document.getElementById('reportBody'); 
            tbody.innerHTML = '';
            
            if (sortedUsers.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" style="padding:8px;border:1px solid #ddd;text-align:center;">No uploads found</td></tr>';
            } else {
                for (const [user, count] of sortedUsers) {
                    tbody.innerHTML += `<tr><td style="padding:8px;border:1px solid #ddd;">${user}</td><td style="padding:8px;border:1px solid #ddd;"><strong>${count}</strong></td></tr>`;
                }
            }
            
            document.getElementById('reportStatus').innerText = ""; 
            document.getElementById('reportTable').style.display = 'table';
        } catch(e) { 
            document.getElementById('reportStatus').innerText = "Error: " + e.message; 
        }
    }

    // --- MY UPLOADS MODAL ---
    function showMyUploads() {
        const worker = document.getElementById('workerName').value.trim();
        if (!worker) {
            alert("Please enter your name first!");
            document.getElementById('workerName').focus();
            return;
        }
        
        document.getElementById('myUploadsModal').style.display = 'block';
        document.getElementById('myUploadsStatus').style.display = 'block';
        document.getElementById('myUploadsStatus').innerText = 'Loading your uploads...';
        document.getElementById('myUploadsGrid').style.display = 'none';
        
        // Get uploads from localStorage
        const allUploads = JSON.parse(localStorage.getItem('ssc_my_uploads') || '[]');
        const myUploads = allUploads
            .filter(u => u.worker === worker)
            .slice(0, 30); // Last 30
        
        document.getElementById('myUploadsStatus').style.display = 'none';
        document.getElementById('myUploadsGrid').style.display = 'grid';
        
        const grid = document.getElementById('myUploadsGrid');
        grid.innerHTML = '';
        
        if (myUploads.length === 0) {
            grid.innerHTML = '<div style="grid-column: 1/-1; text-align:center; padding:40px; color:#666;">No uploads found. Start uploading images to see them here!</div>';
            return;
        }
        
        myUploads.forEach(upload => {
            const item = document.createElement('div');
            item.className = 'upload-item';
            
            // Create image
            const img = document.createElement('img');
            img.src = upload.image;
            img.alt = `ID ${upload.id}`;
            img.className = 'upload-item-image';
            img.onerror = function() {
                this.src = 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'200\' height=\'150\'%3E%3Crect fill=\'%23f3f4f6\' width=\'200\' height=\'150\'/%3E%3Ctext x=\'50%25\' y=\'50%25\' text-anchor=\'middle\' dy=\'.3em\' fill=\'%239ca3af\' font-family=\'sans-serif\' font-size=\'14\'%3EImage not found%3C/text%3E%3C/svg%3E';
            };
            
            // Create ID div with click handler
            const idDiv = document.createElement('div');
            idDiv.className = 'upload-item-id';
            idDiv.textContent = `ID: ${upload.id}`;
            idDiv.title = 'Click to copy ID and fill in input field';
            idDiv.onclick = function(e) {
                e.stopPropagation();
                // Copy to clipboard
                navigator.clipboard.writeText(upload.id).then(() => {
                    // Visual feedback
                    const originalText = idDiv.textContent;
                    idDiv.textContent = '‚úì Copied!';
                    idDiv.style.color = '#10b981';
                    setTimeout(() => {
                        idDiv.textContent = originalText;
                        idDiv.style.color = '#2563eb';
                    }, 1000);
                    
                    // Also fill in the input field
                    document.getElementById('qId').value = upload.id;
                    document.getElementById('qId').focus();
                }).catch(() => {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = upload.id;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    const originalText = idDiv.textContent;
                    idDiv.textContent = '‚úì Copied!';
                    idDiv.style.color = '#10b981';
                    setTimeout(() => {
                        idDiv.textContent = originalText;
                        idDiv.style.color = '#2563eb';
                    }, 1000);
                    
                    document.getElementById('qId').value = upload.id;
                    document.getElementById('qId').focus();
                });
            };
            
            // Create time div
            const timeDiv = document.createElement('div');
            timeDiv.className = 'upload-item-time';
            timeDiv.textContent = upload.time;
            
            // Append all elements
            item.appendChild(img);
            item.appendChild(idDiv);
            item.appendChild(timeDiv);
            grid.appendChild(item);
        });
    }

    // --- HISTORY & COUNTING ---
    function renderHistory() {
        const history = JSON.parse(localStorage.getItem('ssc_upload_history') || '[]');
        
        // Rebuild the Set of uploaded IDs for today to keep count accurate on refresh
        uploadedIDs = new Set();
        history.forEach(item => uploadedIDs.add(item.id));
        document.getElementById('uniqueCount').innerText = uploadedIDs.size;

        const list = document.getElementById('historyList'); list.innerHTML = '';
        if (history.length === 0) { list.innerHTML = '<li style="color:#999;font-size:0.8rem;text-align:center;padding:10px;">No uploads</li>'; return; }
        history.forEach(item => {
            const li = document.createElement('li');
            li.className = 'history-item';
            li.innerHTML = `<span style="color:#2563eb;font-weight:600;">‚úÖ ${item.id}</span> <span style="color:#999;">${item.time}</span>`;
            list.appendChild(li);
        });
    }

    function addToHistory(id, imagePreview = null) {
        const history = JSON.parse(localStorage.getItem('ssc_upload_history') || '[]');
        const worker = document.getElementById('workerName').value.trim();
        
        // Check duplicate BEFORE adding to history (Visually)
        // Note: We track unique counts separately, but history shows all actions
        history.unshift({ id: id, time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) });
        if (history.length > 5) history.pop();
        
        // Add to Set for counting
        uploadedIDs.add(id);
        
        // Store image data for "My Uploads" modal
        if (imagePreview && worker) {
            const uploads = JSON.parse(localStorage.getItem('ssc_my_uploads') || '[]');
            
            // Add new upload
            uploads.unshift({
                id: id,
                worker: worker,
                image: imagePreview, // base64 data URL
                timestamp: new Date().toISOString(),
                time: new Date().toLocaleString()
            });
            
            // Keep only last 30 per worker - separate by worker, keep latest 30, then merge back
            const workers = {};
            uploads.forEach(u => {
                if (!workers[u.worker]) workers[u.worker] = [];
                workers[u.worker].push(u);
            });
            
            const finalUploads = [];
            Object.keys(workers).forEach(w => {
                const workerUploads = workers[w].slice(0, 30); // Keep only last 30
                finalUploads.push(...workerUploads);
            });
            
            // Sort by timestamp (newest first) for consistency
            finalUploads.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            localStorage.setItem('ssc_my_uploads', JSON.stringify(finalUploads));
        }
        
        localStorage.setItem('ssc_upload_history', JSON.stringify(history));
        renderHistory();
    }

    function clearHistory() { if(confirm('Clear history?')) { localStorage.removeItem('ssc_upload_history'); uploadedIDs.clear(); renderHistory(); } }

    // --- TEXT HANDLING ---
    function attachTextListeners(textLayerDiv) {
        // Try multiple times with increasing delays to catch all text spans
        const tryAttach = (attempt = 0) => {
            const spans = textLayerDiv.querySelectorAll('span');
            
            if (spans.length === 0 && attempt < 3) {
                // If no spans found, try again after a delay
                setTimeout(() => tryAttach(attempt + 1), 300);
                return;
            }
            
            spans.forEach(span => {
                // Remove existing listeners to avoid duplicates
                const newSpan = span.cloneNode(true);
                span.parentNode.replaceChild(newSpan, span);
                
                // Make sure span is clickable
                newSpan.style.cursor = 'pointer';
                newSpan.style.userSelect = 'text';
                
                newSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const wrapper = document.getElementById('canvasWrapper');
                    if (!wrapper.classList.contains('text-mode')) return;
                    
                    const text = e.target.innerText || e.target.textContent || '';
                    if (text.trim()) {
                        processTextSelection(text);
                    }
                });
                
                // Also handle double-click for better reliability
                newSpan.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    const wrapper = document.getElementById('canvasWrapper');
                    if (!wrapper.classList.contains('text-mode')) return;
                    
                    const text = e.target.innerText || e.target.textContent || '';
                    if (text.trim()) {
                        processTextSelection(text);
                    }
                });
            });
            
            // Also attach to the entire text layer as fallback
            if (attempt === 0) {
                textLayerDiv.addEventListener('click', (e) => {
                    const wrapper = document.getElementById('canvasWrapper');
                    if (!wrapper.classList.contains('text-mode')) return;
                    
                    // Try to get text from clicked element
                    let target = e.target;
                    let text = '';
                    
                    // Try multiple ways to get text
                    if (target.innerText) text = target.innerText;
                    else if (target.textContent) text = target.textContent;
                    else if (target.closest('span')) {
                        text = target.closest('span').innerText || target.closest('span').textContent;
                    }
                    
                    if (text.trim()) {
                        processTextSelection(text);
                    }
                }, true); // Use capture phase
            }
        };
        
        // Start with initial delay, then retry if needed
        setTimeout(() => tryAttach(0), 100);
        setTimeout(() => tryAttach(0), 500);
        setTimeout(() => tryAttach(0), 1000);
    }
    
    function handleTextSelection() {
        const wrapper = document.getElementById('canvasWrapper');
        if (!wrapper.classList.contains('text-mode')) return;
        const selection = window.getSelection().toString().trim();
        if (selection.length > 0) processTextSelection(selection);
    }

    function processTextSelection(text) {
        if (!text || typeof text !== 'string') return;
        
        // Clean the text - remove extra whitespace and special characters
        text = text.trim().replace(/\s+/g, ' ');
        
        // Try to find numbers - look for patterns like "ID: 123" or "Q.123" or just numbers
        let numbers = text.match(/\d+/g);
        
        // If no numbers found, try to extract from common patterns
        if (!numbers || numbers.length === 0) {
            // Try patterns like "ID:123", "Q123", "Question 123", etc.
            const patterns = [
                /(?:id|ID|Id)[\s:]*(\d+)/i,
                /(?:q|Q|question|Question)[\s.]*(\d+)/i,
                /(\d{2,})/g  // At least 2 digits
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    numbers = [match[1] || match[0]];
                    break;
                }
            }
        }
        
        if (numbers && numbers.length > 0) {
            // Get the longest number (most likely to be the ID)
            const bestMatch = numbers.sort((a, b) => b.length - a.length)[0];
            
            // Only use if it's at least 2 digits (to avoid single digits)
            if (bestMatch.length >= 2) {
                const qIdInput = document.getElementById('qId');
                qIdInput.value = bestMatch;
                qIdInput.classList.add('auto-filled');
                document.getElementById('taskArea').classList.add('flash');
                setTimeout(() => { 
                    qIdInput.classList.remove('auto-filled'); 
                    document.getElementById('taskArea').classList.remove('flash'); 
                }, 500);
                document.getElementById('uploadBtn').focus();
            }
        }
    }

    // --- CORE ---
    function clearAll() {
        document.getElementById('cropPreview').src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        blobToSend = null; document.getElementById('qId').value = "";
        const box = document.getElementById('selectionBox'); box.style.display = 'none'; box.style.width = '0px'; box.style.height = '0px';
    }

    function populateYears() {
        const sel = document.getElementById('year'); const curr = new Date().getFullYear();
        for(let i=curr; i>=2018; i--) { let opt = document.createElement('option'); opt.value = i; opt.text = i; sel.appendChild(opt); }
    }
    
    async function loadPDF(e) {
        const file = e.target.files[0]; if(!file) return;
        const reader = new FileReader();
        reader.onload = async function(ev) {
            pdfDoc = await pdfjsLib.getDocument(new Uint8Array(ev.target.result)).promise;
            renderPage(1);
        };
        reader.readAsArrayBuffer(file);
    }

    async function renderPage(num) {
        if(!pdfDoc) return; pageNum = num;
        const page = await pdfDoc.getPage(num);
        viewport = page.getViewport({ scale: scale });
        canvas.height = viewport.height; canvas.width = viewport.width;
        await page.render({ canvasContext: ctx, viewport: viewport }).promise;

        const textLayerDiv = document.getElementById('textLayer');
        textLayerDiv.innerHTML = ''; // Clear previous content
        textLayerDiv.style.width = `${viewport.width}px`; 
        textLayerDiv.style.height = `${viewport.height}px`;
        textLayerDiv.style.setProperty('--scale-factor', scale);
        
        try {
            const textContent = await page.getTextContent();
            
            // Check if text content exists
            if (textContent && textContent.items && textContent.items.length > 0) {
                await pdfjsLib.renderTextLayer({ 
                    textContentSource: textContent, 
                    container: textLayerDiv, 
                    viewport: viewport, 
                    textDivs: [] 
                }).promise;
                
                // Ensure text layer is visible and interactive when in text mode
                textLayerDiv.style.pointerEvents = 'none'; // Default: disabled
                
                attachTextListeners(textLayerDiv);
            } else {
                // PDF has no extractable text - show message
                console.warn('PDF page has no extractable text content');
                textLayerDiv.innerHTML = '<div style="position:absolute;top:10px;left:10px;background:rgba(255,0,0,0.1);padding:5px;border-radius:4px;font-size:12px;color:#666;">No text layer available</div>';
            }
        } catch (error) {
            console.error('Error rendering text layer:', error);
            // Continue even if text layer fails
        }

        document.getElementById('pageIndicator').innerText = `${num} / ${pdfDoc.numPages}`;
        document.getElementById('selectionBox').style.display = 'none';
    }

    function changePage(delta) {
        const newPage = pageNum + delta;
        if(newPage >= 1 && newPage <= pdfDoc.numPages) renderPage(newPage);
    }
    
    function zoom(delta) { scale = Math.max(0.5, scale + delta); renderPage(pageNum); }

    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) };
    }
    
    function startSelection(e) {
        if (e.ctrlKey || e.metaKey) return;
        isSelecting = true;
        const pos = getMousePos(e); startX = pos.x; startY = pos.y;
        const box = document.getElementById('selectionBox');
        box.style.display = 'block'; box.style.left = (e.clientX - canvas.getBoundingClientRect().left)+'px'; box.style.top = (e.clientY - canvas.getBoundingClientRect().top)+'px'; box.style.width = '0px'; box.style.height = '0px';
    }
    
    function updateSelection(e) {
        if(!isSelecting) return;
        const pos = getMousePos(e);
        rect = { x: Math.min(startX, pos.x), y: Math.min(startY, pos.y), w: Math.abs(pos.x - startX), h: Math.abs(pos.y - startY) };
        const canvasRect = canvas.getBoundingClientRect();
        const scaleX = canvasRect.width / canvas.width; const scaleY = canvasRect.height / canvas.height;
        const box = document.getElementById('selectionBox');
        box.style.left = (rect.x * scaleX) + 'px'; box.style.top = (rect.y * scaleY) + 'px'; box.style.width = (rect.w * scaleX) + 'px'; box.style.height = (rect.h * scaleY) + 'px';
    }
    
    async function endSelection() {
        if(!isSelecting) return; isSelecting = false;
        if(rect.w < 10 || rect.h < 10) return;
        
        // Check if OCR mode is active FIRST
        const wrapper = document.getElementById('canvasWrapper');
        const isOCRMode = wrapper.classList.contains('ocr-mode');
        
        if (isOCRMode) {
            // In OCR mode: Only extract text, don't crop image
            const tempCanvas = document.createElement('canvas'); 
            tempCanvas.width = rect.w; 
            tempCanvas.height = rect.h;
            tempCanvas.getContext('2d').drawImage(canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
            
            // Run OCR without setting crop preview or blob
            await runOCR(tempCanvas);
        } else {
            // Normal mode: Crop image for upload
            const tempCanvas = document.createElement('canvas'); 
            tempCanvas.width = rect.w; 
            tempCanvas.height = rect.h;
            tempCanvas.getContext('2d').drawImage(canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
            
            // Set the image preview and blob
            const imageDataUrl = tempCanvas.toDataURL('image/png');
            document.getElementById('cropPreview').src = imageDataUrl;
            tempCanvas.toBlob(blob => { blobToSend = blob; }, 'image/png');
            
            document.getElementById('qId').focus();
        }
    }
    
    // --- OCR FUNCTIONS ---
    function toggleOCRMode() {
        const wrapper = document.getElementById('canvasWrapper');
        const btn = document.getElementById('ocrModeBtn');
        
        if (wrapper.classList.contains('ocr-mode')) {
            wrapper.classList.remove('ocr-mode');
            wrapper.classList.remove('text-mode');
            btn.style.background = '#10b981';
            btn.textContent = 'üîç OCR Mode';
            updateModeIndicator('none');
        } else {
            wrapper.classList.add('ocr-mode');
            wrapper.classList.remove('text-mode');
            btn.style.background = '#ef4444';
            btn.textContent = '‚ùå Exit OCR';
            updateModeIndicator('ocr');
            // Disable text layer when OCR is active
            const textLayer = document.getElementById('textLayer');
            if (textLayer) {
                textLayer.style.pointerEvents = 'none';
            }
        }
    }
    
    function updateModeIndicator(mode) {
        const indicator = document.getElementById('modeIndicator');
        if (mode === 'text') {
            indicator.textContent = 'TEXT MODE: Highlight or Click ID';
            indicator.style.background = '#2563eb';
        } else if (mode === 'ocr') {
            indicator.textContent = 'OCR MODE: Select area around ID to extract text';
            indicator.style.background = '#10b981';
        } else {
            indicator.style.background = '#2563eb';
        }
    }
    
    async function runOCR(imageCanvas) {
        const loadingDiv = document.getElementById('ocrLoading');
        const progressDiv = document.getElementById('ocrProgress');
        
        try {
            loadingDiv.classList.add('active');
            progressDiv.textContent = 'Initializing OCR engine...';
            
            // Convert canvas to image data
            const imageData = imageCanvas.toDataURL('image/png');
            
            progressDiv.textContent = 'Processing image...';
            
            // Run OCR with Tesseract.js
            const { data: { text } } = await Tesseract.recognize(
                imageData,
                'eng',
                {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            const progress = Math.round(m.progress * 100);
                            progressDiv.textContent = `Reading text... ${progress}%`;
                        }
                    }
                }
            );
            
            progressDiv.textContent = 'Extracting ID...';
            
            // Process the OCR text to extract ID
            if (text && text.trim()) {
                processTextSelection(text);
            } else {
                alert('No text found in selected area. Try selecting a larger area around the ID.');
            }
            
        } catch (error) {
            console.error('OCR Error:', error);
            alert('OCR failed: ' + error.message);
        } finally {
            loadingDiv.classList.remove('active');
            document.getElementById('qId').focus();
        }
    }

    async function uploadImage() {
        const btn = document.getElementById('uploadBtn');
        const token = document.getElementById('ghToken').value;
        const worker = document.getElementById('workerName').value.trim();
        const id = document.getElementById('qId').value.trim();

        if(!token) { alert("Missing Token!"); return; }
        if(!worker) { alert("Enter Name!"); document.getElementById('workerName').focus(); return; }
        if(!id || !blobToSend) { alert("Missing ID/Image!"); return; }

        btn.disabled = true; btn.innerText = "Uploading...";
        const exam = document.getElementById('exam').value; const year = document.getElementById('year').value;
        const tier = document.getElementById('tier').value; const lang = document.getElementById('lang').value;
        const d = document.getElementById('examDate').value.split('-'); 
        if(d.length < 3) { alert("Set Date!"); btn.disabled=false; return; }
        const dateStr = `${d[2]}_${d[1]}_${d[0]}`; 
        const shift = document.getElementById('shift').value;
        const filename = `${id}.png`;
        const path = `ssc/${exam}/${year}/${tier}/${dateStr}/${shift}/${lang}/${filename}`;
        
        const reader = new FileReader();
        reader.readAsDataURL(blobToSend);
        reader.onloadend = async function() {
            const base64data = reader.result.split(',')[1];
            try {
                let sha = null;
                const checkReq = await fetch(`https://api.github.com/repos/${CONFIG.repoOwner}/${CONFIG.repoName}/contents/${path}`, { headers: { Authorization: `Bearer ${token}` } });
                if(checkReq.ok) { sha = (await checkReq.json()).sha; }

                const putBody = { message: `Upload ${filename} (User: ${worker})`, content: base64data };
                if(sha) putBody.sha = sha;

                const res = await fetch(`https://api.github.com/repos/${CONFIG.repoOwner}/${CONFIG.repoName}/contents/${path}`, { method: 'PUT', headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' }, body: JSON.stringify(putBody) });

                if(res.ok) {
                    // Get image preview from crop preview
                    const imagePreview = document.getElementById('cropPreview').src;
                    addToHistory(id, imagePreview); 
                    clearAll();
                    
                    // Turn off OCR mode if it's active
                    const wrapper = document.getElementById('canvasWrapper');
                    if (wrapper.classList.contains('ocr-mode')) {
                        toggleOCRMode();
                    }
                } else { throw new Error("GitHub Error"); }
            } catch(e) { alert("Error: " + e); } 
            finally { btn.disabled = false; btn.innerText = "‚¨ÜÔ∏è Upload"; }
        };
    }

    function saveConfig() { const ids = ['ghToken', 'workerName', 'exam', 'year', 'tier', 'lang', 'examDate', 'shift']; const data = {}; ids.forEach(id => data[id] = document.getElementById(id).value); localStorage.setItem('ssc_cropper_cfg', JSON.stringify(data)); }
    function loadConfig() { const data = JSON.parse(localStorage.getItem('ssc_cropper_cfg')); if(data) { for(let key in data) { if(document.getElementById(key)) document.getElementById(key).value = data[key]; } } }
</script>
</body>
</html>
